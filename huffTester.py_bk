import math
import os
import random
from typing import Any, Dict, List

import heapq
from collections import defaultdict

import cocotb
from cocotb.binary import BinaryValue
from cocotb.clock import Clock
from cocotb.handle import SimHandleBase
from cocotb.queue import Queue
from cocotb.triggers import RisingEdge, ReadOnly

import numpy as np

random.seed(42) # reproducability

NUM_ITERS = 300

#design defines
MAX_STRING_LENGTH = 5
MAX_CHAR_COUNT = 5

class DataMonitor:
    # Instead of taking the whole DUT as input, it only takes the relevant ports
    # from the DUT and works with those, that way it is modular and easily
    # extendable to different things
    def __init__(self, clk, fields, valid):
        self.values = Queue()
        self._clk = clk
        self._fields = fields
        self._valid = valid
        self._coro = None

    def start(self):
        self._coro = cocotb.start_soon(self._run())

    def stop(self):
        self._coro.kill()
        self._coro = None

    async def _run(self) -> None:
        while True:
            await RisingEdge(self._valid)
            await ReadOnly()
            self.values.put_nowait(self._sample())

    def _sample(self):
        return {name: handle.value for name, handle in self._fields.items()}

##main class
class huffTester:
    def __init__(self, dut):
        self.dut = dut

        self.input_monitor = DataMonitor(
            clk=self.dut.clk,
            valid=self.dut.data_en,
            ##inputs
            fields={"data_in": self.dut.data_in, "data_en": self.dut.data_en}
        )

        self.output_monitor = DataMonitor(
            clk=self.dut.clk,
            valid=self.dut.done,
            fields={"character": self.dut.character, "encoded_mask": self.dut.encoded_mask, "encoded_value": self.dut.encoded_value}
        )

        self._checker = None

    def start(self):
        self.input_monitor.start()
        self.output_monitor.start()
        self._checker = cocotb.start_soon(self._check())

    def stop(self):
        self.input_monitor.stop()
        self.output_monitor.stop()
        self._checker.kill()
        self._checker = None

    @cocotb.coroutine
    async def read_output_array(self):
        output_array = []
        for i in range(MAX_CHAR_COUNT): # assuming there are 10 structs in the array
            struct = {}
        # read each field of the struct
            struct["character"] = self.dut.output_array[i].character.value.integer
            struct["encoded_value"] = self.dut.output_array[i].encoded_value.value.integer
            struct["encoded_mask"] = self.dut.output_array[i].encoded_mask.value.integer
            output_array.append(struct)
        return output_array 

    async def _check(self) -> None:
        while True:
            actual = await self.output_monitor.values.get()
            inputs = await self.input_monitor.values.get()
            #vec_out_actual = [x.integer for x in actual["vec_out"]]
            output_actual = await self.read_output_array()
            print(output_actual)

            # Evaluate golden model to figure out expected output
            output_expected = matmul_golden(inputs["data_in"], inputs["data_en"])

            assert output_actual == output_expected

   

##put your golden module here- for now check with manual calculation
def matmul_golden(data_in, data_en):
    #mtx = np.array([x.integer for x in mtx]).reshape((2, 2))
    #vec = np.array([x.integer for x in vec]).reshape((2, 1))

    print(data_in, data_en)
    character = input("anuan")[:MAX_STRING_LENGTH]  
    
    print(character)
    encoded_value = [0,1]
    encoded_mask = [1, 1]
    #vec_out_exp = list(mtx.dot(vec).flatten())
    output = [character,encoded_mask,encoded_value]
    return output
#test-0
@cocotb.test()
async def huffTester1(dut):
    # initialize inputs
    dut.data_in.value = 0x00
    dut.data_en.value = 0
   

    # start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.fork(clock.start())

    # send input data
    input_data = [0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64]  # "Hello World"
    for data in input_data:
        dut.data_in.value = data
        dut.data_en.value = 1
        await RisingEdge(dut.clk)
        dut.data_en.value = 0
        await Timer(1, units="ns")

    # wait for output data
    output_data = []
    while not dut.done.value:
        await RisingEdge(dut.clk)
        if dut.done.value:
            output_data.append(int(dut.data_out.value))

    # check output data
    expected_output = [0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64]  # same as input
    assert output_data == expected_output, f"Expected {expected_output}, but got {output_data}"


#test-1
@cocotb.test()
async def test_huff(dut):
    cocotb.start_soon(Clock(dut.clk, 10, units="ns").start())
    tester = huffTester(dut)

    # Reset DUT
    dut.data_en.value = 0
    dut.reset.value = 0
    await RisingEdge(dut.clk)
    await RisingEdge(dut.clk)
    dut.reset.value = 1

    tester.start()

    for _ in range(NUM_ITERS):
        #dut.data_in.value = [random.randint(0, 255) for _ in range(SIZE*SIZE)]
        my_string = "anusha"
        for char in my_string:
            dut.data_in.value = ord(char)
            print (ord(char))
        await RisingEdge(dut.clk)


        print("I am here")
        dut.data_en.value = 1
        await RisingEdge(dut.clk)
        dut.data_en.value = 0
        await RisingEdge(dut.clk)

        while dut.done.value != 1:
            await RisingEdge(dut.clk)

    for _ in range(20):
        await RisingEdge(dut.clk)

#test-2
# Can have more than one test!
@cocotb.test()
async def test_trivial(dut):
    cocotb.start_soon(Clock(dut.clk, 10, units="ns").start())

    # Reset DUT
    dut.data_en.value = 0
    dut.reset.value = 1
    await RisingEdge(dut.clk)
    await RisingEdge(dut.clk)

    dut.reset.value = 0
    await RisingEdge(dut.clk)
    await RisingEdge(dut.clk)

    assert dut.done.value == 0
